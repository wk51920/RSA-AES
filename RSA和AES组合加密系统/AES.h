#include <iostream>
#include <cstdio>
#include <bitset>
#include <string>
using namespace std;
const unsigned char Sbox[]=
{
	//0    1   2    3    4    5    6    7    8    9    A    B    C    D    E    F
	0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,//0
	0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,//1
	0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,//2
	0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,//3
	0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,//4
	0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,//5
	0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,//6
	0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,//7
	0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,//8
	0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,//9
	0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,//A
	0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,//B
	0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,//C
	0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,//D
	0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,//E
	0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16,//F
};
 const unsigned char InvSbox[]=
{
	//0    1    2    3    4    5    6    7    8    9    A    B    C     D    E   F 
	0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,//0
	0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,//1
	0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,//2
	0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,//3
	0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,//4
	0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,//5
	0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,//6
	0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,//7
	0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,//8
	0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,//9
	0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,//A
	0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,//B
	0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,//C
	0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,//D
	0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,//E
	0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D,//F
};
class AES
{
public:
AES();
~AES();
void setkey(char output1[]);          //将RSA传输过来的密钥输入AES系统
void SubBytes(unsigned char state[][4]); // 字节替换
void InvSubBytes(unsigned char state[][4]); //逆字节替换
void ShiftRows(unsigned char state[][4]); //行移位
void InvShiftRows(unsigned char state[][4]); //逆行移位
unsigned char Mul(const unsigned char &left,const unsigned char &right) ;// 实现两字节在GF（2^8）上的相乘运算
void MixColumns(unsigned char state[][4]);    //列混淆
void InvMixColumns(unsigned char state[][4]); //逆列混淆
void AddRoundKey(unsigned char state[][4],unsigned char k[][4]); //轮密钥加
void KeyExpansion(unsigned char* key, unsigned char w[][4][4]); //密钥扩展
unsigned char *Cipher(unsigned char *input);  //加密 
unsigned char *InvCipher(unsigned char *input); //解密
 // 密文输入格式重载  解决超过128字节的输入
void *Cipher(void *input,int length=0)
{
	unsigned char* in = (unsigned char*) input;
	int i;
	if(!length)
	{
		while(*(in+length++));
		in = (unsigned char*) input;
	}
	for(i=0; i<length; i+=16)
	{
		Cipher(in+i);
	}
	return input;
}      
//解密明文格式重载
void *InvCipher(void *input,int length)
{
	
	unsigned char* in = (unsigned char*) input;
	int i;
	for(i=0; i<length; i+=16)
	{
		InvCipher(in+i);
	}
	return input;
}
void print(unsigned char* state);  //打印

private:
unsigned char key[16]; 
unsigned char input[16];
unsigned char w[11][4][4];
};
AES::AES()
{

}
AES::~AES(){}
void AES::setkey(char output1[])
{
	for(int i=0;i<16;i++)
		key[i]=(unsigned char)output1[i];
	KeyExpansion(key,w);
}
void AES::SubBytes(unsigned char state[][4])
{
	int r,c;
	for(r=0;r<4;r++)
		for(c=0;c<4;c++)
			state[r][c]=Sbox[state[r][c]];
}
void AES::InvSubBytes(unsigned char state[][4])
{
	int r,c;
	for(r=0;r<4;r++)
		for(c=0;c<4;c++)
		  state[r][c]=InvSbox[state[r][c]];
}
void AES::ShiftRows(unsigned char state[][4])
{
	
	unsigned char temp;
	temp=state[1][0];
	int i=0;
    while(1)    //第二行循环左移一个字节
	{
		
		state[1][i]=state[1][i+1];
        i++;
		if(i==3)
		{
			state[1][3]=temp;
			break;
		}
	}
	temp=state[2][0]; //第三行循环左移两个字节
	state[2][0]=state[2][2];
	state[2][2]=temp;
	temp=state[2][1];
	state[2][1]=state[2][3];
	state[2][3]=temp;

	temp=state[3][3];   // 第四行循环左移三个字节
	i=3;
	while(1)
	{
		state[3][i]=state[3][i-1];
		i--;
		if(i==0)
		{
			state[3][0]=temp;
			break;
		}
	}
}
void AES::InvShiftRows(unsigned char state[][4])
{
	unsigned char temp;
	temp=state[1][3];       //第二行循环右移一个字节
	for(int i=3;i>=1;i--)
	  state[1][i]=state[1][i-1];
	state[1][0]=temp;
	
	temp=state[2][0];//第三行循环右移两个字节
	state[2][0]=state[2][2];
	state[2][2]=temp;
	temp=state[2][1];
	state[2][1]=state[2][3];
	state[2][3]=temp;

	temp=state[3][0];//第四行循环右移三个字节
	for(int i=0;i<=2;i++)
		state[3][i]=state[3][i+1];
	state[3][3]=temp;
}
unsigned char AES:: Mul(const unsigned char &left,const unsigned char &right) // 实现两字节在GF（2^8）上的相乘运算
{
	unsigned char temp[8];
	bitset<8> bits((unsigned long)right);//把right化为8个二进制位存放在bits中
	unsigned char result=0x00;
	temp[0]=left;
	for(int i=1;i<8;++i)
	{
		if(temp[i-1]>=0x80) //若temp[i-1]首位为“1”
		{
			temp[i]=temp[i-1]<<1;
			temp[i]=temp[i]^0x1b; //与（0001 1011）异或
		}
		else
		{
			temp[i]=temp[i-1]<<1;
		}
	}
	for(int i=0;i<8;i++)
	{
        if(bits[i]==1)
		{
			result=result^temp[i];
		}
	}
	return result;

}
void AES::MixColumns(unsigned char state[][4])
{
	unsigned char t[4]={0};
	int r;
	for(r=0;r<4;r++)
	{
		t[0]=Mul(0x02,state[0][r])^Mul(0x03,state[1][r])^state[2][r]^state[3][r];
		t[1]=state[0][r]^Mul(0x02,state[1][r])^Mul(0x03,state[2][r])^state[3][r];
		t[2]=state[0][r]^state[1][r]^Mul(0x02,state[2][r])^Mul(0x03,state[3][r]);
		t[3]=Mul(0x03,state[0][r])^state[1][r]^state[2][r]^Mul(0x02,state[3][r]);
		state[0][r]=t[0];
		state[1][r]=t[1];
		state[2][r]=t[2];
		state[3][r]=t[3];
	}
}
void AES::InvMixColumns(unsigned char state[][4])
{
	unsigned char temp[4];
	for(int j=0;j<4;j++)
	{
		temp[0]=Mul(0x0e,state[0][j])^Mul(0x0b,state[1][j])^Mul(0x0d,state[2][j])^Mul(0x09,state[3][j]);
		temp[1]=Mul(0x09,state[0][j])^Mul(0x0e,state[1][j])^Mul(0x0b,state[2][j])^Mul(0x0d,state[3][j]);
		temp[2]=Mul(0x0d,state[0][j])^Mul(0x09,state[1][j])^Mul(0x0e,state[2][j])^Mul(0x0b,state[3][j]);
		temp[3]=Mul(0x0b,state[0][j])^Mul(0x0d,state[1][j])^Mul(0x09,state[2][j])^Mul(0x0e,state[3][j]);
    	for(int i=0;i<4;i++) 
	    	state[i][j]=temp[i];
	}
}
void AES::AddRoundKey(unsigned char state[][4],unsigned char k[][4])
{
	int r,c;
	for(c=0; c<4; c++)
	{
		for(r=0; r<4; r++)
		{
			state[r][c] ^= k[r][c];
		}
	}

}
void AES::KeyExpansion(unsigned char* key, unsigned char w[][4][4])
{
	int i,j,r,c;
	unsigned char rc[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};
	for(r=0; r<4; r++)
	{
		for(c=0; c<4; c++)
		{
			w[0][r][c] = key[r+c*4];
		}
	}
	for(i=1; i<=10; i++)
	{
		for(j=0; j<4; j++)
		{
			unsigned char t[4];
			for(r=0; r<4; r++)
			{
				t[r] = j ? w[i][r][j-1] : w[i-1][r][3];
			}
			if(j == 0)
			{
				unsigned char temp = t[0];
				for(r=0; r<3; r++)
				{
					t[r] = Sbox[t[(r+1)%4]];
				}
				t[3] = Sbox[temp];
				t[0] ^= rc[i-1];
			}
			for(r=0; r<4; r++)
			{
				w[i][r][j] = w[i-1][r][j] ^ t[r];
			}
		}
	}
}
unsigned char *AES::Cipher(unsigned char *input)
{
	unsigned char state[4][4];
	int i,r,c;

	for(r=0; r<4; r++)
	{
		for(c=0; c<4 ;c++)
		{
			state[r][c] = input[c*4+r];
		}
	}
    AddRoundKey(state,w[0]);

	for(i=1; i<=10; i++)
	{
		SubBytes(state);
		ShiftRows(state);
		if(i!=10)MixColumns(state);
		AddRoundKey(state,w[i]);
	}

	for(r=0; r<4; r++)
	{
		for(c=0; c<4 ;c++)
		{
			input[c*4+r] = state[r][c];
		}
	}

	return input;
}
unsigned char *AES::InvCipher(unsigned char *input)
{
	unsigned char state[4][4];
	int i,r,c;

	for(r=0; r<4; r++)
	{
		for(c=0; c<4 ;c++)
		{
			state[r][c] = input[c*4+r];
		}
	}

	AddRoundKey(state, w[10]);
	for(i=9; i>=0; i--)
	{
		InvShiftRows(state);
		InvSubBytes(state);
		AddRoundKey(state, w[i]);
		if(i)
		{
			InvMixColumns(state);
		}
	}
	
	for(r=0; r<4; r++)
	{
		for(c=0; c<4 ;c++)
		{
			input[c*4+r] = state[r][c];
		}
	}

	return input;
}
void AES::print(unsigned char* state)
{
	int i;
	for(i=0; i<16; i++)
	{
		printf("%s%X ",state[i]>15 ? "" : "0", state[i]);
	}
	printf("\n");
}